/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│vi: set net ft=c ts=2 sts=2 sw=2 fenc=utf-8                                :vi│
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#define ShouldUseMsabiAttribute() 1
#include "libc/calls/calls.h"
#include "libc/calls/internal.h"
#include "libc/calls/ntspawn.h"
#include "libc/calls/syscall-nt.internal.h"
#include "libc/fmt/itoa.h"
#include "libc/intrin/kprintf.h"
#include "libc/intrin/strace.internal.h"
#include "libc/intrin/weaken.h"
#include "libc/macros.internal.h"
#include "libc/mem/alloca.h"
#include "libc/nt/accounting.h"
#include "libc/nt/console.h"
#include "libc/nt/enum/startf.h"
#include "libc/nt/enum/status.h"
#include "libc/nt/memory.h"
#include "libc/nt/runtime.h"
#include "libc/nt/struct/processinformation.h"
#include "libc/nt/struct/startupinfo.h"
#include "libc/nt/synchronization.h"
#include "libc/nt/thread.h"
#include "libc/nt/thunk/msabi.h"
#include "libc/runtime/internal.h"
#include "libc/runtime/memtrack.internal.h"
#include "libc/runtime/runtime.h"
#include "libc/runtime/stack.h"
#include "libc/sock/sock.h"
#include "libc/str/str.h"
#include "libc/sysv/consts/at.h"
#include "libc/sysv/consts/map.h"
#include "libc/sysv/consts/o.h"
#include "libc/sysv/consts/ok.h"
#include "libc/sysv/consts/sig.h"
#include "libc/sysv/errfuns.h"
#include "libc/thread/thread.h"

#define keywords textwindows dontasan dontubsan dontinstrument

extern long __klog_handle;

__msabi extern typeof(CloseHandle) *const __imp_CloseHandle;
__msabi extern typeof(GetExitCodeProcess) *const __imp_GetExitCodeProcess;
__msabi extern typeof(TerminateThread) *const __imp_TerminateThread;
__msabi extern typeof(UnmapViewOfFile) *const __imp_UnmapViewOfFile;
__msabi extern typeof(WaitForSingleObject) *const __imp_WaitForSingleObject;

wontreturn void __switch_stacks(intptr_t, long, long, long,
                                void (*)(intptr_t, intptr_t, long, long),
                                intptr_t);

__msabi static keywords bool32 sys_execve_nt_event(uint32_t dwCtrlType) {
  return true;  // block sigint and sigquit in execve() parent process
}

static keywords void PurgeHandle(intptr_t h) {
  if (!h) return;
  if (h == -1) return;
  __imp_CloseHandle(h);
}

static keywords void PurgeThread(intptr_t h) {
  if (h && h != -1) {
    __imp_TerminateThread(h, SIGKILL);
    __imp_CloseHandle(h);
  }
}

// this function runs on the original tiny stack that windows gave us.
// we need to keep the original process alive simply to pass an int32.
// so we unmap all memory to avoid getting a double whammy after fork.
static keywords void sys_execve_nt_relay(intptr_t h, long b, long c, long d) {
  uint32_t i, dwExitCode;
  __imp_SetConsoleCtrlHandler((void *)sys_execve_nt_event, 1);
  PurgeThread(g_fds.stdin.thread);
  PurgeHandle(g_fds.stdin.reader);
  PurgeHandle(g_fds.stdin.writer);
  PurgeHandle(g_fds.p[0].handle);
  PurgeHandle(g_fds.p[1].handle);
  PurgeHandle(g_fds.p[2].handle);
  for (i = 0; i < _mmi.i; ++i) {
    __imp_UnmapViewOfFile((void *)((uintptr_t)_mmi.p[i].x << 16));
    PurgeHandle(_mmi.p[i].h);
  }
  do {
    __imp_WaitForSingleObject(h, -1);
    dwExitCode = kNtStillActive;
    __imp_GetExitCodeProcess(h, &dwExitCode);
  } while (dwExitCode == kNtStillActive);
  __imp_ExitProcess(dwExitCode);
  __builtin_unreachable();
}

keywords int sys_execve_nt(const char *program, char *const argv[],
                           char *const envp[]) {
  int rc;
  size_t i;
  char progbuf[PATH_MAX];
  struct NtStartupInfo startinfo;
  struct NtProcessInformation procinfo;

  if (strlen(program) + 4 + 1 > PATH_MAX) {
    return enametoolong();
  }

  // this is a non-recoverable operation, so do some manual validation
  if (sys_faccessat_nt(AT_FDCWD, program, X_OK, 0) == -1) {
    stpcpy(stpcpy(progbuf, program), ".com");
    if (sys_faccessat_nt(AT_FDCWD, progbuf, X_OK, 0) != -1) {
      program = progbuf;
    } else {
      stpcpy(stpcpy(progbuf, program), ".exe");
      if (sys_faccessat_nt(AT_FDCWD, progbuf, X_OK, 0) != -1) {
        program = progbuf;
      } else {
        return eacces();
      }
    }
  }

  //////////////////////////////////////////////////////////////////////////////
  // execve operation is unrecoverable from this point

  if (_weaken(pthread_kill_siblings_np)) {
    _weaken(pthread_kill_siblings_np)();
  }

  // close non-stdio and cloexec handles
  for (i = 0; i < g_fds.n; ++i) {
    if (g_fds.p[i].kind == kFdEmpty) {
      g_fds.p[i].handle = -1;
    } else if (i > 2 || (g_fds.p[i].flags & O_CLOEXEC)) {
      PurgeHandle(g_fds.p[i].handle);
      g_fds.p[i].handle = -1;
    }
  }

  if (_weaken(__klog_handle) &&        //
      *_weaken(__klog_handle) != 0 &&  //
      *_weaken(__klog_handle) != -1) {
    PurgeHandle(*_weaken(__klog_handle));
  }

  int bits;
  char buf[32], *v = 0;
  if (_weaken(socket)) {
    for (bits = i = 0; i < 3; ++i) {
      if (g_fds.p[i].kind == kFdSocket) {
        bits |= 1 << i;
      }
    }
    FormatInt32(stpcpy(buf, "__STDIO_SOCKETS="), bits);
    v = buf;
  }
  bzero(&startinfo, sizeof(startinfo));
  startinfo.cb = sizeof(struct NtStartupInfo);
  startinfo.dwFlags = kNtStartfUsestdhandles;
  startinfo.hStdInput = g_fds.p[0].handle;
  startinfo.hStdOutput = g_fds.p[1].handle;
  startinfo.hStdError = g_fds.p[2].handle;

  // spawn the process
  rc = ntspawn(program, argv, envp, v, 0, 0, true, 0, 0, &startinfo, &procinfo);
  if (rc == -1) {
    STRACE("panic: unrecoverable ntspawn(%#s) error: %m", program);
    __imp_ExitProcess(11);
  }

  //////////////////////////////////////////////////////////////////////////////
  // zombify this process which lingers on to relay the status code

  PurgeHandle(procinfo.hThread);
  __switch_stacks(procinfo.hProcess, 0, 0, 0, sys_execve_nt_relay, __oldstack);
}
