/*-*- mode:unix-assembly; indent-tabs-mode:t; tab-width:8; coding:utf-8     -*-â”‚
â”‚vi: set et ft=asm ts=8 tw=8 fenc=utf-8                                     :viâ”‚
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
â”‚ Copyright 2020 Justine Alexandra Roberts Tunney                              â”‚
â”‚                                                                              â”‚
â”‚ Permission to use, copy, modify, and/or distribute this software for         â”‚
â”‚ any purpose with or without fee is hereby granted, provided that the         â”‚
â”‚ above copyright notice and this permission notice appear in all copies.      â”‚
â”‚                                                                              â”‚
â”‚ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL                â”‚
â”‚ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                â”‚
â”‚ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             â”‚
â”‚ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         â”‚
â”‚ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        â”‚
â”‚ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               â”‚
â”‚ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             â”‚
â”‚ PERFORMANCE OF THIS SOFTWARE.                                                â”‚
â•šâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
#include "libc/nexgen32e/macros.h"
#include "libc/nexgen32e/x86feature.h"
#include "libc/macros.h"

/	Mutates string to uppercase roman characters.
/
/	@param	RDI points to non-const NUL-terminated string
/	@return	RAX will be original RDI
/	@note	10x faster than C
strtoupper:
	mov	$'A-'a,%edx			# adding this uppers
	mov	$'a|'z<<8,%ecx			# uint8_t range a..z
	jmp	strcaseconv
	.endfn	strtoupper,globl

/	Mutates string to lowercase roman characters.
/
/	@param	RDI points to non-const NUL-terminated string
/	@return	RAX will be original RDI
/	@note	10x faster than C
strtolower:
	mov	$'a-'A,%edx			# adding this lowers
	mov	$'A|'Z<<8,%ecx			# uint8_t range A..Z
/	ğ‘ ğ‘™ğ‘–ğ‘‘ğ‘’
	.endfn	strtolower,globl

/	Support code for strtolower() and strtoupper().
/
/	@param	RDI points to non-const NUL-terminated string
/	@param	CL defines start of character range to mutate
/	@param	CH defines end of character range to mutate
/	@param	DL is added to each DIL âˆˆ [CL,CH]
/	@return	RAX will be original RDI
strcaseconv:
	.leafprologue
	.profilable
	mov	%rdi,%rsi
0:	testb	$15,%sil			# is it aligned?
#if X86_NEED(SSE4_2)
	jz	.Lsse4
#else
	jnz	1f
	testb	X86_HAVE(SSE4_2)+kCpuids(%rip)
	jnz	.Lsse4				# is it nehalem?
#endif
1:	lodsb					# AL = *RSI++
	test	%al,%al				# is it NUL?
	jz	3f
	cmp	%cl,%al				# is it in range?
	jb	0b
	cmp	%ch,%al
	ja	0b
	add	%dl,-1(%rsi)
	jmp	0b
.Lsse4:	movd	%ecx,%xmm1			# XMM1 = ['A,'Z,0,0,...]
	movd	%edx,%xmm2			# XMM2 = ['a-'A,'a-'A,...]
	pbroadcastb %xmm2
	xor	%ecx,%ecx
2:	movdqa	(%rsi,%rcx),%xmm3
/	              â”Œâ”€0:index of the LEAST significant, set, bit is used
/	              â”‚   regardless of corresponding input element validity
/	              â”‚   intres2 is returned in least significant bits of xmm0
/	              â”œâ”€1:index of the MOST significant, set, bit is used
/	              â”‚   regardless of corresponding input element validity
/	              â”‚   each bit of intres2 is expanded to byte/word
/	              â”‚â”Œâ”€0:negation of intres1 is for all 16 (8) bits
/	              â”‚â”œâ”€1:negation of intres1 is masked by reg/mem validity
/	              â”‚â”‚â”Œâ”€intres1 is negated (1â€™s complement)
/	              â”‚â”‚â”‚â”Œâ”€mode{equalany,ranges,equaleach,equalordered}
/	              â”‚â”‚â”‚â”‚ â”Œâ”€issigned
/	              â”‚â”‚â”‚â”‚ â”‚â”Œâ”€is16bit
/	             uâ”‚â”‚â”‚â”œâ”â”‚â”‚
	pcmpistrm $0b01000100,%xmm3,%xmm1	# â†’XMM0 8-bit byte mask
	pand	%xmm2,%xmm0			#  won't mask after NUL
	paddb	%xmm0,%xmm3
	movdqa	%xmm3,(%rsi,%rcx)
	lea	16(%rcx),%rcx
	jnz	2b				# PCMPISTRM found NUL
3:	mov	%rdi,%rax
	.leafepilogue
	.endfn	strcaseconv
	.source	__FILE__
