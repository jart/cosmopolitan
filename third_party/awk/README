AWK(1)                       General Commands Manual                      AWK(1)



ğğ€ğŒğ„
       awk - pattern-directed scanning and processing language

ğ’ğ˜ğğğğ’ğˆğ’
       ğ—®ğ˜„ğ—¸ [ -ğ… fÌ²sÌ² ] [ -ğ˜ƒ vÌ²aÌ²rÌ²=Ì²vÌ²aÌ²lÌ²uÌ²eÌ² ] [ 'Ì²pÌ²rÌ²oÌ²gÌ²'Ì² | -ğ—³ pÌ²rÌ²oÌ²gÌ²fÌ²iÌ²lÌ²eÌ² ] [ fÌ²iÌ²lÌ²eÌ² .Ì².Ì².Ì²  ]

ğƒğ„ğ’ğ‚ğ‘ğˆğğ“ğˆğğ
       AÌ²wÌ²kÌ²  scans  each input fÌ²iÌ²lÌ²eÌ² for lines that match any of a set of patterns
       specified literally in pÌ²rÌ²oÌ²gÌ² or in one or more files specified as -ğ—³ pÌ²rÌ²oÌ²gÌ²â€Ì²
       fÌ²iÌ²lÌ²eÌ².   With  each pattern there can be an associated action that will be
       performed when a line of a  fÌ²iÌ²lÌ²eÌ²  matches  the  pattern.   Each  line  is
       matched  against  the  pattern portion of every pattern-action statement;
       the associated action is performed for each matched  pattern.   The  file
       name  -  means  the  standard  input.   Any fÌ²iÌ²lÌ²eÌ² of the form vÌ²aÌ²rÌ²=Ì²vÌ²aÌ²lÌ²uÌ²eÌ² is
       treated as an assignment, not a filename, and is executed at the time  it
       would  have been opened if it were a filename.  The option -ğ˜ƒ followed by
       vÌ²aÌ²rÌ²=Ì²vÌ²aÌ²lÌ²uÌ²eÌ² is an assignment to be done before pÌ²rÌ²oÌ²gÌ² is executed; any number
       of  -ğ˜ƒ  options may be present.  The -ğ… fÌ²sÌ² option defines the input field
       separator to be the regular expression fÌ²sÌ².

       An input line is normally made up of fields separated by white space,  or
       by  the regular expression ğ…ğ’.  The fields are denoted $ğŸ­, $ğŸ®, ..., while
       $ğŸ¬ refers to the entire line.  If ğ…ğ’ is null, the  input  line  is  split
       into one field per character.

       A pattern-action statement has the form:

              pÌ²aÌ²tÌ²tÌ²eÌ²rÌ²nÌ² { aÌ²cÌ²tÌ²iÌ²oÌ²nÌ² }

       A  missing  {  aÌ²cÌ²tÌ²iÌ²oÌ²nÌ²  }  means  print the line; a missing pattern always
       matches.  Pattern-action statements are separated by  newlines  or  semiâ€
       colons.

       An  action  is  a  sequence of statements.  A statement can be one of the
       following:

              if( eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² ) sÌ²tÌ²aÌ²tÌ²eÌ²mÌ²eÌ²nÌ²tÌ² [ else sÌ²tÌ²aÌ²tÌ²eÌ²mÌ²eÌ²nÌ²tÌ² ]
              while( eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² ) sÌ²tÌ²aÌ²tÌ²eÌ²mÌ²eÌ²nÌ²tÌ²
              for( eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² ; eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² ; eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² ) sÌ²tÌ²aÌ²tÌ²eÌ²mÌ²eÌ²nÌ²tÌ²
              for( vÌ²aÌ²rÌ² in aÌ²rÌ²rÌ²aÌ²yÌ² ) sÌ²tÌ²aÌ²tÌ²eÌ²mÌ²eÌ²nÌ²tÌ²
              do sÌ²tÌ²aÌ²tÌ²eÌ²mÌ²eÌ²nÌ²tÌ² while( eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² )
              break
              continue
              { [ sÌ²tÌ²aÌ²tÌ²eÌ²mÌ²eÌ²nÌ²tÌ² .Ì².Ì².Ì² ] }
              eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ²              # commonly vÌ²aÌ²rÌ² =Ì² eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ²
              print [ eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ²-Ì²lÌ²iÌ²sÌ²tÌ² ] [ > eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² ]
              printf fÌ²oÌ²rÌ²mÌ²aÌ²tÌ² [ , eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ²-Ì²lÌ²iÌ²sÌ²tÌ² ] [ > eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² ]
              return [ eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² ]
              next                    # skip remaining patterns on this input line
              nextfile                # skip rest of this file, open next, start at top
              delete aÌ²rÌ²rÌ²aÌ²yÌ²[ eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² ]# delete an array element
              delete aÌ²rÌ²rÌ²aÌ²yÌ²            # delete all elements of array
              exit [ eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² ]     # exit immediately; status is eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ²

       Statements are terminated by semicolons, newlines or  right  braces.   An
       empty  eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ²-Ì²lÌ²iÌ²sÌ²tÌ²  stands  for $ğŸ¬.  String constants are quoted " ",
       with the usual C escapes recognized within.  Expressions take  on  string
       or numeric values as appropriate, and are built using the operators + - *
       / % ^ (exponentiation), and concatenation  (indicated  by  white  space).
       The  operators  !  ++  --  +=  -= *= /= %= ^= > >= < <= == != ?: are also
       available in expressions.  Variables may be scalars, array elements  (deâ€
       noted  xÌ²[iÌ²])  or  fields.   Variables are initialized to the null string.
       Array subscripts may be any string, not necessarily numeric; this  allows
       for  a  form  of associative memory.  Multiple subscripts such as [ğ—¶,ğ—·,ğ—¸]
       are permitted; the constituents are concatenated, separated by the  value
       of ğ’ğ”ğğ’ğ„ğ.

       The  ğ—½ğ—¿ğ—¶ğ—»ğ˜ statement prints its arguments on the standard output (or on a
       file if > fÌ²iÌ²lÌ²eÌ² or >> fÌ²iÌ²lÌ²eÌ² is present or on a pipe if | cÌ²mÌ²dÌ²  is  present),
       separated  by  the  current output field separator, and terminated by the
       output record separator.  fÌ²iÌ²lÌ²eÌ² and cÌ²mÌ²dÌ² may be literal names or  parentheâ€
       sized expressions; identical string values in different statements denote
       the same open file.  The ğ—½ğ—¿ğ—¶ğ—»ğ˜ğ—³ statement formats its expression list acâ€
       cording to the fÌ²oÌ²rÌ²mÌ²aÌ²tÌ² (see pÌ²rÌ²iÌ²nÌ²tÌ²fÌ²(3)).  The built-in function ğ—°ğ—¹ğ—¼ğ˜€ğ—²(eÌ²xÌ²pÌ²rÌ²)
       closes the file or pipe eÌ²xÌ²pÌ²rÌ².  The built-in function ğ—³ğ—³ğ—¹ğ˜‚ğ˜€ğ—µ(eÌ²xÌ²pÌ²rÌ²) flushes
       any buffered output for the file or pipe eÌ²xÌ²pÌ²rÌ².

       The  mathematical functions ğ—®ğ˜ğ—®ğ—»ğŸ®, ğ—°ğ—¼ğ˜€, ğ—²ğ˜…ğ—½, ğ—¹ğ—¼ğ—´, ğ˜€ğ—¶ğ—», and ğ˜€ğ—¾ğ—¿ğ˜ are built
       in.  Other built-in functions:


       ğ—¹ğ—²ğ—»ğ—´ğ˜ğ—µ  the length of its argument taken as a string, number of  elements
               in  an  array  for an array argument, or length of $ğŸ¬ if no arguâ€
               ment.
       ğ—¿ğ—®ğ—»ğ—±    random number on [0,1).
       ğ˜€ğ—¿ğ—®ğ—»ğ—±   sets seed for ğ—¿ğ—®ğ—»ğ—± and returns the previous seed.
       ğ—¶ğ—»ğ˜     truncates to an integer value.
       ğ˜€ğ˜‚ğ—¯ğ˜€ğ˜ğ—¿(sÌ², mÌ² [, nÌ²])
               the nÌ²-character substring of sÌ² that begins at position mÌ²  counted
               from 1.  If no nÌ², use the rest of the string.
       ğ—¶ğ—»ğ—±ğ—²ğ˜…(sÌ², tÌ²)
               the position in sÌ² where the string tÌ² occurs, or 0 if it does not.
       ğ—ºğ—®ğ˜ğ—°ğ—µ(sÌ², rÌ²)
               the  position in sÌ² where the regular expression rÌ² occurs, or 0 if
               it does not.  The variables ğ‘ğ’ğ“ğ€ğ‘ğ“ and ğ‘ğ‹ğ„ğğ†ğ“ğ‡ are set to the poâ€
               sition and length of the matched string.
       ğ˜€ğ—½ğ—¹ğ—¶ğ˜(sÌ², aÌ² [, fÌ²sÌ²])
               splits  the  string  sÌ² into array elements aÌ²[ğŸ­], aÌ²[ğŸ®], ..., aÌ²[nÌ²],
               and returns nÌ².  The separation is done with the  regular  expresâ€
               sion  fÌ²sÌ²  or  with the field separator ğ…ğ’ if fÌ²sÌ² is not given.  An
               empty string as field separator splits the string into one  array
               element per character.
       ğ˜€ğ˜‚ğ—¯(rÌ², tÌ² [, sÌ²])
               substitutes  tÌ² for the first occurrence of the regular expression
               rÌ² in the string sÌ².  If sÌ² is not given, $ğŸ¬ is used.
       ğ—´ğ˜€ğ˜‚ğ—¯(rÌ², tÌ² [, sÌ²])
               same as ğ˜€ğ˜‚ğ—¯ except that all occurrences of the regular expression
               are replaced; ğ˜€ğ˜‚ğ—¯ and ğ—´ğ˜€ğ˜‚ğ—¯ return the number of replacements.
       ğ˜€ğ—½ğ—¿ğ—¶ğ—»ğ˜ğ—³(fÌ²mÌ²tÌ², eÌ²xÌ²pÌ²rÌ², .Ì².Ì².Ì²)
               the  string  resulting from formatting eÌ²xÌ²pÌ²rÌ² .Ì².Ì².Ì²  according to the
               pÌ²rÌ²iÌ²nÌ²tÌ²fÌ²(3) format fÌ²mÌ²tÌ².
       ğ˜€ğ˜†ğ˜€ğ˜ğ—²ğ—º(cÌ²mÌ²dÌ²)
               executes cÌ²mÌ²dÌ² and returns its exit status. This will  be  -1  upon
               error,  cÌ²mÌ²dÌ²'s  exit  status  upon  a  normal exit, 256 + sÌ²iÌ²gÌ² upon
               death-by-signal, where sÌ²iÌ²gÌ² is the number of the murdering signal,
               or 512 + sÌ²iÌ²gÌ² if there was a core dump.
       ğ˜ğ—¼ğ—¹ğ—¼ğ˜„ğ—²ğ—¿(sÌ²tÌ²rÌ²)
               returns  a  copy of sÌ²tÌ²rÌ² with all upper-case characters translated
               to their corresponding lower-case equivalents.
       ğ˜ğ—¼ğ˜‚ğ—½ğ—½ğ—²ğ—¿(sÌ²tÌ²rÌ²)
               returns a copy of sÌ²tÌ²rÌ² with all lower-case  characters  translated
               to their corresponding upper-case equivalents.

       The  ``function''  ğ—´ğ—²ğ˜ğ—¹ğ—¶ğ—»ğ—² sets $ğŸ¬ to the next input record from the curâ€
       rent input file; ğ—´ğ—²ğ˜ğ—¹ğ—¶ğ—»ğ—² < fÌ²iÌ²lÌ²eÌ² sets $ğŸ¬ to the  next  record  from  fÌ²iÌ²lÌ²eÌ².
       ğ—´ğ—²ğ˜ğ—¹ğ—¶ğ—»ğ—² xÌ² sets variable xÌ² instead.  Finally, cÌ²mÌ²dÌ² | ğ—´ğ—²ğ˜ğ—¹ğ—¶ğ—»ğ—² pipes the outâ€
       put of cÌ²mÌ²dÌ² into ğ—´ğ—²ğ˜ğ—¹ğ—¶ğ—»ğ—²; each call of ğ—´ğ—²ğ˜ğ—¹ğ—¶ğ—»ğ—² returns the  next  line  of
       output from cÌ²mÌ²dÌ².  In all cases, ğ—´ğ—²ğ˜ğ—¹ğ—¶ğ—»ğ—² returns 1 for a successful input,
       0 for end of file, and -1 for an error.

       Patterns are arbitrary Boolean combinations (with ! || &&) of regular exâ€
       pressions  and  relational  expressions.   Regular  expressions are as in
       eÌ²gÌ²rÌ²eÌ²pÌ²; see gÌ²rÌ²eÌ²pÌ²(1).  Isolated regular expressions in a pattern  apply  to
       the  entire  line.   Regular expressions may also occur in relational exâ€
       pressions, using the operators ~ and !~.  /rÌ²eÌ²/ is a constant regular  exâ€
       pression;  any string (constant or variable) may be used as a regular exâ€
       pression, except in the position of an isolated regular expression  in  a
       pattern.

       A pattern may consist of two patterns separated by a comma; in this case,
       the action is performed for all lines from an  occurrence  of  the  first
       pattern though an occurrence of the second.

       A relational expression is one of the following:

              eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² mÌ²aÌ²tÌ²cÌ²hÌ²oÌ²pÌ² rÌ²eÌ²gÌ²uÌ²lÌ²aÌ²rÌ²-Ì²eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ²
              eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² rÌ²eÌ²lÌ²oÌ²pÌ² eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ²
              eÌ²xÌ²pÌ²rÌ²eÌ²sÌ²sÌ²iÌ²oÌ²nÌ² ğ—¶ğ—» aÌ²rÌ²rÌ²aÌ²yÌ²-Ì²nÌ²aÌ²mÌ²eÌ²
              (eÌ²xÌ²pÌ²rÌ²,eÌ²xÌ²pÌ²rÌ²,Ì².Ì².Ì².Ì²) ğ—¶ğ—» aÌ²rÌ²rÌ²aÌ²yÌ²-Ì²nÌ²aÌ²mÌ²eÌ²

       where  a rÌ²eÌ²lÌ²oÌ²pÌ² is any of the six relational operators in C, and a mÌ²aÌ²tÌ²cÌ²hÌ²oÌ²pÌ²
       is either ~ (matches) or !~ (does not match).  A conditional is an arithâ€
       metic  expression,  a  relational expression, or a Boolean combination of
       these.

       The special patterns ğğ„ğ†ğˆğ and ğ„ğğƒ may be used to capture control  before
       the  first  input  line is read and after the last.  ğğ„ğ†ğˆğ and ğ„ğğƒ do not
       combine with other patterns.  They may appear multiple times in a program
       and execute in the order they are read by aÌ²wÌ²kÌ².

       Variable names with special meanings:


       ğ€ğ‘ğ†ğ‚      argument count, assignable.
       ğ€ğ‘ğ†ğ•      argument array, assignable; non-null members are taken as fileâ€
                 names.
       ğ‚ğğğ•ğ…ğŒğ“   conversion format used when converting numbers (default %.ğŸ²ğ—´).
       ğ„ğğ•ğˆğ‘ğğ   array of environment variables; subscripts are names.
       ğ…ğˆğ‹ğ„ğğ€ğŒğ„  the name of the current input file.
       ğ…ğğ‘       ordinal number of the current record in the current file.
       ğ…ğ’        regular expression used to separate fields;  also  settable  by
                 option -ğ…fÌ²sÌ².
       ğğ…        number of fields in the current record.
       ğğ‘        ordinal number of the current record.
       ğğ…ğŒğ“      output format for numbers (default %.ğŸ²ğ—´).
       ğğ…ğ’       output field separator (default space).
       ğğ‘ğ’       output record separator (default newline).
       ğ‘ğ‹ğ„ğğ†ğ“ğ‡   the length of a string matched by ğ—ºğ—®ğ˜ğ—°ğ—µ.
       ğ‘ğ’        input  record  separator  (default  newline).   If empty, blank
                 lines separate records.  If more than one character long, ğ‘ğ’ is
                 treated  as  a regular expression, and records are separated by
                 text matching the expression.
       ğ‘ğ’ğ“ğ€ğ‘ğ“    the start position of a string matched by ğ—ºğ—®ğ˜ğ—°ğ—µ.
       ğ’ğ”ğğ’ğ„ğ    separates multiple subscripts (default 034).

       Functions may be defined (at the position of a pattern-action  statement)
       thus:

              ğ—³ğ˜‚ğ—»ğ—°ğ˜ğ—¶ğ—¼ğ—» ğ—³ğ—¼ğ—¼(ğ—®, ğ—¯, ğ—°) { ...; ğ—¿ğ—²ğ˜ğ˜‚ğ—¿ğ—» ğ˜… }

       Parameters  are passed by value if scalar and by reference if array name;
       functions may be called recursively.  Parameters are local to  the  funcâ€
       tion;  all  other variables are global.  Thus local variables may be creâ€
       ated by providing excess parameters in the function definition.

ğ„ğğ•ğˆğ‘ğğğŒğ„ğğ“ ğ•ğ€ğ‘ğˆğ€ğğ‹ğ„ğ’
       If ğğğ’ğˆğ—ğ‹ğ˜_ğ‚ğğ‘ğ‘ğ„ğ‚ğ“ is set in the environment, then aÌ²wÌ²kÌ² follows the  POSIX
       rules for ğ˜€ğ˜‚ğ—¯ and ğ—´ğ˜€ğ˜‚ğ—¯ with respect to consecutive backslashes and amperâ€
       sands.

ğ„ğ—ğ€ğŒğğ‹ğ„ğ’
       length($0) > 72
              Print lines longer than 72 characters.

       { print $2, $1 }
              Print first two fields in opposite order.

       BEGIN { FS = ",[ \t]*|[ \t]+" }
             { print $2, $1 }
              Same, with input fields separated by comma and/or spaces and tabs.

            { s += $1 }
       END  { print "sum is", s, " average is", s/NR }
              Add up first column, print sum and average.

       /start/, /stop/
              Print all lines between start/stop pairs.

       BEGIN     {    # Simulate echo(1)
            for (i = 1; i < ARGC; i++) printf "%s ", ARGV[i]
            printf "\n"
            exit }

ğ’ğ„ğ„ ğ€ğ‹ğ’ğ
       gÌ²rÌ²eÌ²pÌ²(1), lÌ²eÌ²xÌ²(1), sÌ²eÌ²dÌ²(1)
       A. V. Aho, B. W. Kernighan, P. J. Weinberger, TÌ²hÌ²eÌ²  AÌ²WÌ²KÌ²  PÌ²rÌ²oÌ²gÌ²rÌ²aÌ²mÌ²mÌ²iÌ²nÌ²gÌ²  LÌ²aÌ²nÌ²â€Ì²
       gÌ²uÌ²aÌ²gÌ²eÌ², Addison-Wesley, 1988.  ISBN 0-201-07981-X.

ğğ”ğ†ğ’
       There  are no explicit conversions between numbers and strings.  To force
       an expression to be treated as a number add 0 to it; to force  it  to  be
       treated as a string concatenate "" to it.

       The  scope  rules  for  variables in functions are a botch; the syntax is
       worse.

       Only eight-bit characters sets are handled correctly.

ğ”ğğ”ğ’ğ”ğ€ğ‹ ğ…ğ‹ğğ€ğ“ğˆğğ†-ğğğˆğğ“ ğ•ğ€ğ‹ğ”ğ„ğ’
       AÌ²wÌ²kÌ² was designed before IEEE 754 arithmetic  defined  Not-A-Number  (NaN)
       and  Infinity  values,  which  are supported by all modern floating-point
       hardware.

       Because aÌ²wÌ²kÌ² uses sÌ²tÌ²rÌ²tÌ²oÌ²dÌ²(3) and aÌ²tÌ²oÌ²fÌ²(3) to convert string values  to  douâ€
       ble-precision  floating-point  values,  modern  C  libraries also convert
       strings starting with ğ—¶ğ—»ğ—³ and ğ—»ğ—®ğ—» into infinity and  NaN  values  respecâ€
       tively.  This led to strange results, with something like this:

       echo nancy | awk '{ print $1 + 0 }'

       printing ğ—»ğ—®ğ—» instead of zero.

       AÌ²wÌ²kÌ²  now  follows GNU AWK, and prefilters string values before attempting
       to convert them to numbers, as follows:

       HÌ²eÌ²xÌ²aÌ²dÌ²eÌ²cÌ²iÌ²mÌ²aÌ²lÌ² vÌ²aÌ²lÌ²uÌ²eÌ²sÌ²
              Hexadecimal values (allowed since C99) convert to  zero,  as  they
              did prior to C99.

       NÌ²aÌ²NÌ² vÌ²aÌ²lÌ²uÌ²eÌ²sÌ²
              The  two  strings +ğ—»ğ—®ğ—» and -ğ—»ğ—®ğ—» (case independent) convert to NaN.
              No others do.  (NaNs can have signs.)

       IÌ²nÌ²fÌ²iÌ²nÌ²iÌ²tÌ²yÌ² vÌ²aÌ²lÌ²uÌ²eÌ²sÌ²
              The two strings +ğ—¶ğ—»ğ—³ and -ğ—¶ğ—»ğ—³ (case independent) convert to  posiâ€
              tive and negative infinity, respectively.  No others do.



                                                                          AWK(1)
